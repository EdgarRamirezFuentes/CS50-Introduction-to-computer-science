sort1 uses: bubble sort

How do you know?: First, I compared the time of each sorting algorithm by using the sorted text files because I know that the
Omega complexity of this algorithm is Ω(n). Hence, the bubble sort is the first algorithm that finishes its execution because
merge sort has a Omega complexity of Ω(n log n), which is bigger than Ω(n), and selection sort will be the last to be executed due to its
Omega complexity is Ω(n²). Then, I compared the time of each algorithm by using the random text files and comparing the time of execution of each
sort. It is known that the O complexity of this algorithm is O(n²), the O complexity of merge sort is O(n log n), and the O complexity of the bubble
sort is O(n²). Checking the first comparison of time and the second comparison one, the bubble sort belongs to the sort1 executable.

sort2 uses: merge sort

How do you know?: Using the technique explained in bubble sort, the merge sort is the second algorithm to finish its execution using
the sorted data because its Omega complexity, which is Ω(n log n), is bigger than Ω(n) and it is smaller than Ω(n²). Hence, comparing
the execution time, the second algorithm to finish its execution was sort2. Then, I compared the time by using random data and
knowing that the O complexity of this algorithm O(n log n), the first algorithm to finish its execution will be merge sort, which was sort2.


sort3 uses: selection sort

How do you know?: This sort was the last one, so... selection sort belongs to this executable hahaha
